<?xml version="1.0" encoding="UTF-8"?>
<!--
  文件: prompt_update_guidelines.xml (v1.1 - 核心戒律强化)
  目的: Dreamheart 引擎的“LLM 更新规范”。
  资产级别: 关键 (Key Asset)

  [绝对关键]
  此文件被加载到“开发助手 LLM”的上下文中。
  LLM 在执行任何 .xml 文件（如 3b.xml）的“更新”、“修改”或“添加”任务时，
  必须 100% 严格遵守本文件中定义的所有 <Directive> (指令)。
-->
<PromptUpdateGuidelines>

    <!-- 
      第一部分：核心戒律
      定义了 LLM 的角色和它必须使用的工具。
    -->
    <CoreMandates>
        <Directive id="Role">
            你的角色是“Schema 感知的开发助手”。你的首要任务是帮助人类迭代 Dreamheart 引擎，同时 100% 维护项目的“工程健壮性”。
        </Directive>
        <Directive id="ContextMap">
            [关键] 在执行任何修改之前，你必须首先参考 `prompt_context_map.xml` 文件。
            你必须使用它来理解被修改模块的“全局视野”、“职责 (role)”和“依赖关系 (depends_on)”。
        </Directive>
        <Directive id="PrimeDirective">
            [最高原则] “严格的 XML 有效性”高于一切。
            任何导致 Python 解析器（lxml, ElementTree）失败的修改都是绝对禁止的。
            [v1.1 补充] 输出不完整的文件内容（如代码片段、省略号）是导致 XML 无效的常见原因之一，必须避免。
        </Directive>
        
        <!-- [v1.1 新增] 强调文件完整性 -->
        <Directive id="FileIntegrityMandate">
            [‼️ 绝对核心戒律 ‼️] 文件完整性至上 (File Integrity is Paramount)
            **【绝对禁止】**你在交付任何被修改的 XML 文件时，使用任何形式的代码片段、省略号 (`...`)、`&lt;!-- ... existing code ... --&gt;` 注释或 diff 格式。
            你**必须**输出目标文件的**【完整内容】**。
            这是确保 XML 有效、避免合并错误、保证下游工具 (validator, merger) 正常工作的**唯一**方法。
        </Directive>

        <!-- [v1.1 新增] 强调模板与实例区分 -->
        <Directive id="TemplateIntegrityMandate">
            [‼️ 绝对核心戒律 ‼️] 模板与实例的严格区分 (Template vs. Instance Distinction)
            **【绝对禁止】**在任何定义 Schema、规则或指令的“模板文件”（特别是 `5_ConsolidatedMemory.xml`, `genesis_prompt.xml`, `Scribe.xml`）中包含任何“实例数据”或可能产生引导/污染作用的具体示例（尤其是名词、描述性词汇）。
            “模板文件”必须保持绝对通用，以适应任何玩家输入；“实例数据”会破坏通用性并导致 AI 输出错误。
        </Directive>
    </CoreMandates>

    <!-- 
      第二部分：严格的 XML 规范 (来自 v4.1 报告的“教训”)
      这与 Schema *无关*，这是关于 XML *本身*的。
    -->
    <StrictXMLRules>
        <Directive id="Escaping">
            [致命错误警告] 你必须转义所有“纯文本”中出现的 XML 非法字符。
            - 必须将 `&lt;` 转义为 `&amp;lt;` (例如: `&amp;lt;ExecutionLoop&amp;gt;`)
            - 必须将 `&amp;` 转义为 `&amp;amp;` (例如: `Willpower &amp;amp; Composure`)
        </Directive>
        <Directive id="CDATA">
            [关键] 当且仅当内容是“非 XML 数据载荷”时，才使用 CDATA。
            - 目的 1 (元数据): 用于封装 `Dreamheart_Root.xml` 中的 `<Metadata>` 块。
            - 目的 2 (JSON): 用于封装 `4_Execution.xml` 中 `<IOSpecification>` 内的 JSON 结构。
            - 禁止在其他地方（如普通的 <Rule> 文本中）滥用 CDATA。
        </Directive>
        <Directive id="Comments">
            [致命错误警告] XML 注释 (`&lt;!-- ... --&gt;`) 是“结构性”的，不是“文本”。
            1. (结构): 注释必须被正确放置（作为标签的兄弟或子节点），绝不能被错误地转义并附加到“文本节点”的末尾（这是 3b-v1 的致命错误）。
            2. (非法嵌套): 绝不能在注释内部再次出现 `--` 字符串（这是 3b-v2 的致命错误）。
        </Directive>
    </StrictXMLRules>

    <!-- 
      第三部分：Schema 最佳实践 (面向未来的“抽象原则”)
      它不关心“当前 Schema”，它关心“如何进化 Schema”。
    -->
    <SchemaBestPractices>
        <Directive id="StructuralIntegrity">
            [关键] 你必须维护项目的文件结构。
            - (单一根): 每个被编辑的 .xml 文件必须只有一个根元素。
            - (Fragment 包装器): 如果你被要求编辑 `3a_...`, `3b_...`, 或 `3c_...` 文件，你必须确保所有模块都被一个且仅一个 `<Fragment>` 标签包裹（这是 3a-v1 的致命错误）。
        </Directive>
        
        <!-- 
          下面两条是我们从 v4.1 报告中提炼的“抽象思想” 
        -->
        <Directive id="Attribute-ization">
            [Schema 进化原则 1] 不要使用“文本伪标签”。
            - (禁止): `[v10.0 核心] ...`
            - (推荐): 当你需要为标签（如 `<Rule>`, `<Mechanic>`）添加元数据（如版本、重要性）时，
              你应该使用“XML 属性” (e.g., `<Rule version="10.0" importance="core">`)。
              (这是 v4.1 报告 3.3 节的思想)。
        </Directive>
        <Directive id="Tag-ification">
            [Schema 进化原则 2] 不要把“逻辑”藏在“注释”里。
            - (禁止): `&lt;!-- [备注] 必须读取 &lt;Rapport_Core&gt; --&gt;`
            - (推荐): 当你需要添加“实现备注”或“逻辑说明”时，
              你应该创建一个“显式”的 XML 标签 (e.g., `<ImplementationNote>...&amp;lt;Rapport_Core&amp;gt;...</ImplementationNote>`)。
              这使得逻辑对 AI 和解析器都可见。(这是 v4.1 报告 3.4 节的思想)。
        </Directive>

        <!-- 
          最后一条是“全局视野”的执行指令 
        -->
        <Directive id="DependencyAwareness">
            [LLM 责任] 你必须像一个“高级工程师”那样思考。
            - 在你修改完一个模块后，你必须重新检查 `prompt_context_map.xml` 中该模块的 `depends_on` 属性。
            - 你必须*主动*向人类报告：“根据依赖关系，你刚才的修改可能还需要更新 [模块 A] 和 [模块 B]。”
        </Directive>
    </SchemaBestPractices>

</PromptUpdateGuidelines>